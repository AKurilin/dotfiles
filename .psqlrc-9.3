\set QUIET 1

\set PROMPT1 '%M:%> %n@%/%R%#%x '
\set PROMPT2 '%M %n@%/%R %# '
\pset null '(null)'
\set COMP_KEYWORD_CASE upper
\timing
\set VERBOSITY verbose
\set version 'SELECT version();'
\set extensions 'select * from pg_available_extensions;'
\set HISTSIZE 2000

\set QUIET 0

\set r 'ROLLBACK;'
\set b 'BEGIN;'
\set e 'EXPLAIN'
\set ea 'EXPLAIN (ANALYZE)'
\set eaa 'EXPLAIN (ANALYZE, BUFFERS, TIMING)'
\set su 'SET ROLE super;' --helpful queries
\set uptime 'select now() - backend_start as uptime from pg_stat_activity where pid = pg_backend_pid();'
\set show_slow_queries '(SELECT (total_time / 1000 / 60) as total_minutes, (total_time/calls) as average_time, query FROM pg_stat_statements ORDER BY 1 DESC LIMIT 100);'
\set settings '(select name, setting,unit,context from pg_settings);'
\set locked '(SELECT bl.pid AS blocked_pid, a.usename AS blocked_user, kl.pid AS blocking_pid, ka.usename AS blocking_user, a.query AS blocked_statement FROM pg_catalog.pg_locks bl JOIN pg_catalog.pg_stat_activity a ON bl.pid = a.pid JOIN pg_catalog.pg_locks kl JOIN pg_catalog.pg_stat_activity ka ON kl.pid = ka.pid ON bl.transactionid = kl.transactionid AND bl.pid != kl.pid WHERE NOT bl.granted);'
\set conninfo 'select usename, count(*) from pg_stat_activity group by usename;'
\set activity '(select datname, pid, usename, application_name,client_addr, client_hostname, client_port, query, state from pg_stat_activity);'
\set active '(select datname, pid, usename, application_name,client_addr, client_hostname, client_port, query, waiting from pg_stat_activity where state = ''active'');'
\set waits '(SELECT pg_stat_activity.pid, pg_stat_activity.query, pg_stat_activity.waiting, now() - pg_stat_activity.query_start AS \"totaltime\", pg_stat_activity.backend_start FROM pg_stat_activity WHERE pg_stat_activity.query !~ \'%IDLE%\'::text AND pg_stat_activity.waiting = true);'
\set long '( select * FROM pg_stat_activity where state <> ''idle'' AND now() - pg_stat_activity.query_start > interval ''5 minutes'' ORDER BY now() - pg_stat_activity.query_start DESC);'
\set dbsize 'SELECT datname, pg_size_pretty(pg_database_size(datname)) db_size FROM pg_database ORDER BY db_size;' -- 4 helpful queries from radek http://radek.cc/2009/08/15/psqlrc-tricks-table-sizes/
\set missingindexes 'select src_table, dst_table, fk_name, pg_size_pretty(s_size) as s_size, pg_size_pretty(d_size) as d_size, d from ( select distinct on (1,2,3,4,5) textin(regclassout(c.conrelid)) as src_table, textin(regclassout(c.confrelid)) as dst_table, c.conname as fk_name, pg_relation_size(c.conrelid) as s_size, pg_relation_size(c.confrelid) as d_size, array_upper(di.indkey::int[], 1) + 1 - array_upper(c.conkey::int[], 1) as d from pg_constraint c left join pg_index di on di.indrelid = c.conrelid and array_to_string(di.indkey, '' '') ~ (''^'' || array_to_string(c.conkey, '' '') || ''( |$)'') join pg_stat_user_tables st on st.relid = c.conrelid where c.contype = ''f'' order by 1,2,3,4,5,6 asc) mfk where mfk.d is distinct from 0 and mfk.s_size > 1000000 order by mfk.s_size desc, mfk.d desc;'
\set rtsize '(select table_schema, table_name, pg_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) as size, pg_total_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) as total_size from information_schema.tables where table_type = \'BASE TABLE\' and table_schema not in (\'information_schema\', \'pg_catalog\') order by pg_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) desc, table_schema, table_name);'
\set tablesize '(select table_schema, table_name, pg_size_pretty(size) as size, pg_size_pretty(total_size) as total_size from (:rtsize) x order by x.size desc, x.total_size desc, table_schema, table_name);'
\set tlocks '(SELECT locked.pid AS locked_pid, locker.pid AS locker_pid, locked_act.usename AS locked_user, locker_act.usename AS locker_user, locked.virtualtransaction, locked.transactionid, relname FROM pg_locks locked LEFT OUTER JOIN pg_class ON (locked.relation = pg_class.oid), pg_locks locker, pg_stat_activity locked_act, pg_stat_activity locker_act WHERE locker.granted=true AND locked.granted=false AND locked.pid=locked_act.pid AND locker.pid=locker_act.pid AND locked.relation=locker.relation);'
\set locks '(SELECT locktype, virtualtransaction, transactionid, nspname, relname, mode, granted, cast(date_trunc(\'second\',query_start) AS timestamp) AS query_start, substr(query,1,25) AS query FROM pg_locks LEFT OUTER JOIN pg_class ON (pg_locks.relation = pg_class.oid) LEFT OUTER JOIN pg_namespace ON (pg_namespace.oid = pg_class.relnamespace), pg_stat_activity WHERE NOT pg_locks.pid=pg_backend_pid() AND pg_locks.pid=pg_stat_activity.pid);'
\set xlocks '(SELECT locked.pid AS locked_pid, locker.pid AS locker_pid, locked_act.usename AS locked_user, locker_act.usename AS locker_user, locked.virtualtransaction, locked.transactionid, locked.locktype FROM pg_locks locked, pg_locks locker, pg_stat_activity locked_act, pg_stat_activity locker_act WHERE locker.granted=true AND locked.granted=false AND locked.pid=locked_act.pid AND locker.pid=locker_act.pid AND (locked.virtualtransaction=locker.virtualtransaction OR locked.transactionid=locker.transactionid));'
\set bloat '(WITH btree_index_atts AS ( SELECT nspname, relname, reltuples, relpages, indrelid, relam, regexp_split_to_table(indkey::text, '' '')::smallint AS attnum, indexrelid as index_oid FROM pg_index JOIN pg_class ON pg_class.oid=pg_index.indexrelid JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace JOIN pg_am ON pg_class.relam = pg_am.oid WHERE pg_am.amname = ''btree''), index_item_sizes AS ( SELECT i.nspname, i.relname, i.reltuples, i.relpages, i.relam, s.starelid, a.attrelid AS table_oid, index_oid, current_setting(''block_size'')::numeric AS bs, CASE WHEN version() ~ ''mingw32'' OR version() ~ ''64-bit'' THEN 8 ELSE 4 END AS maxalign, 24 AS pagehdr, CASE WHEN max(coalesce(s.stanullfrac,0)) = 0 THEN 2 ELSE 6 END AS index_tuple_hdr, sum( (1-coalesce(s.stanullfrac, 0)) * coalesce(s.stawidth, 2048) ) AS nulldatawidth FROM pg_attribute AS a JOIN pg_statistic AS s ON s.starelid=a.attrelid AND s.staattnum = a.attnum JOIN btree_index_atts AS i ON i.indrelid = a.attrelid AND a.attnum = i.attnum WHERE a.attnum > 0 GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9), index_aligned AS ( SELECT maxalign, bs, nspname, relname AS index_name, reltuples, relpages, relam, table_oid, index_oid, ( 2 + maxalign - CASE WHEN 2%maxalign = 0 THEN maxalign ELSE 2%maxalign END + nulldatawidth + maxalign - CASE WHEN nulldatawidth::integer%maxalign = 0 THEN maxalign ELSE nulldatawidth::integer%maxalign END)::numeric AS nulldatahdrwidth, pagehdr FROM index_item_sizes AS s1), otta_calc AS ( SELECT bs, nspname, table_oid, index_oid, index_name, relpages, coalesce( ceil((reltuples*(4+nulldatahdrwidth))/(bs-pagehdr::float)) + CASE WHEN am.amname IN (''hash'',''btree'') THEN 1 ELSE 0 END , 0 ) AS otta FROM index_aligned AS s2 LEFT JOIN pg_am am ON s2.relam = am.oid), raw_bloat AS ( SELECT current_database() as dbname, nspname, c.relname AS table_name, index_name, bs*(sub.relpages)::bigint AS totalbytes, CASE WHEN sub.relpages <= otta THEN 0 ELSE bs*(sub.relpages-otta)::bigint END AS wastedbytes, CASE WHEN sub.relpages <= otta THEN 0 ELSE bs*(sub.relpages-otta)::bigint * 100 / (bs*(sub.relpages)::bigint) END AS realbloat, pg_relation_size(sub.table_oid) as table_bytes, stat.idx_scan as index_scans FROM otta_calc AS sub JOIN pg_class AS c ON c.oid=sub.table_oid JOIN pg_stat_user_indexes AS stat ON sub.index_oid = stat.indexrelid) SELECT dbname as database_name, nspname as schema_name, table_name, index_name, round(realbloat, 1) as bloat_pct, wastedbytes as bloat_bytes, pg_size_pretty(wastedbytes) as bloat_size, totalbytes as index_bytes, pg_size_pretty(totalbytes) as index_size, table_bytes, pg_size_pretty(table_bytes) as table_size, index_scans FROM raw_bloat WHERE ( realbloat > 50 and wastedbytes > 50000000 ) ORDER BY wastedbytes DESC);'
\set tableindexusage '(SELECT relname, 100 * idx_scan / (seq_scan + idx_scan) percent_of_times_index_used, n_live_tup rows_in_table FROM pg_stat_user_tables WHERE seq_scan + idx_scan > 0 ORDER BY n_live_tup DESC);'
\set roletree '(WITH RECURSIVE membership_tree(grpid, userid) AS ( SELECT pg_roles.oid, pg_roles.oid FROM pg_roles UNION ALL SELECT m_1.roleid, t_1.userid FROM pg_auth_members m_1, membership_tree t_1 WHERE m_1.member = t_1.grpid) SELECT DISTINCT t.userid, r.rolname AS usrname, t.grpid, m.rolname AS grpname FROM membership_tree t, pg_roles r, pg_roles m WHERE t.grpid = m.oid AND t.userid = r.oid ORDER BY r.rolname, m.rolname);'
\set lag 'SELECT client_hostname, client_addr, ( (cur_xlog * 255 * 16 ^ 6) + cur_offset) - ((replay_xlog * 255 * 16 ^ 6) + replay_offset) as total_lag, pg_size_pretty((( (cur_xlog * 255 * 16 ^ 6) + cur_offset) - ((replay_xlog * 255 * 16 ^ 6) + replay_offset))::numeric) as total_nice, ((sent_xlog * 255 * 16 ^ 6) + sent_offset) - ((replay_xlog * 255 * 16 ^ 6) + replay_offset) as byte_lag, pg_size_pretty((( (sent_xlog * 255 * 16 ^ 6) + sent_offset) - ((replay_xlog * 255 * 16 ^ 6) + replay_offset))::numeric) as byte_nice FROM ( SELECT client_hostname, client_addr, (''x'' || lpad(split_part(sent_location, ''/'', 1), 8, ''0''))::bit(32)::bigint AS sent_xlog, (''x'' || lpad(split_part(replay_location, ''/'', 1), 8, ''0''))::bit(32)::bigint AS replay_xlog, (''x'' || lpad(split_part(sent_location, ''/'', 2), 8, ''0''))::bit(32)::bigint AS sent_offset, (''x'' || lpad(split_part(replay_location, ''/'', 2), 8, ''0''))::bit(32)::bigint AS replay_offset, (''x'' || lpad(split_part(pg_current_xlog_location(), ''/'', 1), 8, ''0''))::bit(32)::bigint as cur_xlog, (''x'' || lpad(split_part(pg_current_xlog_location(), ''/'', 2), 8, ''0''))::bit(32)::bigint as cur_offset FROM pg_stat_replication ) as s;'
\set freeze 'SELECT relname, age(relfrozenxid) as xid_age, pg_size_pretty(pg_table_size(oid)) as table_size FROM pg_class WHERE relkind = ''r'' and pg_table_size(oid) > 1073741824 ORDER BY age(relfrozenxid) DESC LIMIT 20;'
\set setting 'SELECT name, current_setting(name), source FROM pg_settings WHERE source NOT IN (''default'', ''override'') and name != ''archive_command'';'
\set walstat '(SELECT (100 * checkpoints_req) / (checkpoints_timed + checkpoints_req) AS checkpoints_req_pct, pg_size_pretty(buffers_checkpoint * block_size / (checkpoints_timed + checkpoints_req)) AS avg_checkpoint_write, pg_size_pretty(block_size * (buffers_checkpoint + buffers_clean + buffers_backend)) AS total_written, 100 * buffers_checkpoint / (buffers_checkpoint + buffers_clean + buffers_backend) AS checkpoint_write_pct, 100 * buffers_backend / (buffers_checkpoint + buffers_clean + buffers_backend) AS backend_write_pct, * FROM pg_stat_bgwriter,(SELECT cast(current_setting(''block_size'') AS integer) AS block_size) AS bs);'
\set badindex 'WITH table_scans as ( SELECT relid, tables.idx_scan + tables.seq_scan as all_scans, ( tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del ) as writes, pg_relation_size(relid) as table_size FROM pg_stat_user_tables as tables), all_writes as ( SELECT sum(writes) as total_writes FROM table_scans), indexes as ( SELECT idx_stat.relid, idx_stat.indexrelid, idx_stat.schemaname, idx_stat.relname as tablename, idx_stat.indexrelname as indexname, idx_stat.idx_scan, pg_relation_size(idx_stat.indexrelid) as index_bytes, indexdef ~* ''USING btree'' AS idx_is_btree FROM pg_stat_user_indexes as idx_stat JOIN pg_index USING (indexrelid) JOIN pg_indexes as indexes ON idx_stat.schemaname = indexes.schemaname AND idx_stat.relname = indexes.tablename AND idx_stat.indexrelname = indexes.indexname WHERE pg_index.indisunique = FALSE), index_ratios AS ( SELECT schemaname, tablename, indexname, idx_scan, all_scans, round(( CASE WHEN all_scans = 0 THEN 0.0::NUMERIC ELSE idx_scan::NUMERIC/all_scans * 100 END),2) as index_scan_pct, writes, round((CASE WHEN writes = 0 THEN idx_scan::NUMERIC ELSE idx_scan::NUMERIC/writes END),2) as scans_per_write, pg_size_pretty(index_bytes) as index_size, pg_size_pretty(table_size) as table_size, idx_is_btree, index_bytes FROM indexes JOIN table_scans USING (relid)), index_groups AS ( SELECT ''Never Used Indexes'' as reason, *, 1 as grp FROM index_ratios WHERE idx_scan = 0 and idx_is_btree UNION ALL SELECT ''Low Scans, High Writes'' as reason, *, 2 as grp FROM index_ratios WHERE scans_per_write <= 1 and index_scan_pct < 10 and idx_scan > 0 and writes > 100 and idx_is_btree UNION ALL SELECT ''Seldom Used Large Indexes'' as reason, *, 3 as grp FROM index_ratios WHERE index_scan_pct < 5 and scans_per_write > 1 and idx_scan > 0 and idx_is_btree and index_bytes > 100000000 UNION ALL SELECT ''High-Write Large Non-Btree'' as reason, index_ratios.*, 4 as grp FROM index_ratios, all_writes WHERE ( case when total_writes = 0 THEN 0 ELSE (writes::NUMERIC / total_writes) END ) > 0.02 AND NOT idx_is_btree AND index_bytes > 100000000 ORDER BY grp, index_bytes DESC ) SELECT reason, schemaname, tablename, indexname, index_scan_pct, scans_per_write, index_size, table_size FROM index_groups;'
\set bgstat 'with bgstats as ( select checkpoints_timed, checkpoints_req, checkpoints_timed + checkpoints_req as checkpoints, checkpoint_sync_time, checkpoint_write_time, buffers_checkpoint, buffers_clean, maxwritten_clean, buffers_backend, buffers_backend_fsync, buffers_alloc, buffers_checkpoint + buffers_clean + buffers_backend as total_buffers, round(extract(''epoch'' from now() - stats_reset)/60)::numeric as min_since_reset, lru.setting::numeric as bgwriter_maxpages, delay.setting::numeric as bgwriter_delay from pg_stat_bgwriter cross join pg_settings as lru cross join pg_settings as delay where lru.name = ''bgwriter_lru_maxpages'' and delay.name = ''bgwriter_delay'') select CASE WHEN checkpoints > 0 THEN round(checkpoints_req*100/checkpoints,1) END as pct_checkpoints_req, CASE WHEN checkpoints > 0 THEN round(min_since_reset/checkpoints,2) END as avg_frequency_min, CASE WHEN checkpoints > 0 THEN round(checkpoint_write_time::numeric/(checkpoints*1000),2) END as avg_write_time_s, CASE WHEN checkpoints > 0 THEN round(checkpoint_sync_time::numeric/(checkpoints*1000),2) END as avg_sync_time_s, round(total_buffers/128::numeric,1) as mb_written, round(total_buffers/(128 * min_since_reset),2) as mb_written_per_min, CASE WHEN checkpoints > 0 THEN round(buffers_checkpoint/(checkpoints*128::numeric),2) END as mb_per_checkpoint, CASE WHEN total_buffers > 0 THEN round(buffers_checkpoint*100/total_buffers::numeric,1) END as pct_checkpoint_buffers, CASE WHEN total_buffers > 0 THEN round(buffers_clean*100/total_buffers::numeric,1) END as pct_bgwriter_buffers, CASE WHEN total_buffers > 0 THEN round(buffers_backend*100/total_buffers::numeric,1) END as pct_backend_buffers, round(maxwritten_clean*100::numeric/(min_since_reset*60000/bgwriter_delay),2) as bgwriter_halt_freq, CASE WHEN buffers_clean > 0 THEN round(maxwritten_clean*100::numeric/(buffers_clean/bgwriter_maxpages),2) END as bgwriter_halt_potential, CASE WHEN total_buffers > 0 THEN round(buffers_alloc::numeric/total_buffers,3) END as buffer_allocation_ratio from bgstats;'
\set buffusage '(select usagecount, count(*), isdirty from pg_buffercache group by isdirty, usagecount order by isdirty, usagecount);'
\set buffrel '(SELECT c.relname, pg_size_pretty(count(*) * 8192) as buffered, round(100.0 * count(*) / (SELECT setting FROM pg_settings WHERE name=''shared_buffers'')::integer,1) AS buffers_percent, round(100.0 * count(*) * 8192 / pg_relation_size(c.oid),1) AS percent_of_relation FROM pg_class c INNER JOIN pg_buffercache b ON b.relfilenode = c.relfilenode INNER JOIN pg_database d ON (b.reldatabase = d.oid AND d.datname = current_database()) GROUP BY c.oid,c.relname ORDER BY 3 DESC LIMIT 10);'
